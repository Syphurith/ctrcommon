#include "ctrcommon/screen.hpp"

#include "service.hpp"

#include <stdio.h>
#include <string.h>

#include <3ds.h>
#include <malloc.h>

static unsigned char asciiData[128][8] = {
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x3E, 0x41, 0x55, 0x41, 0x55, 0x49, 0x3E},
        {0x00, 0x3E, 0x7F, 0x6B, 0x7F, 0x6B, 0x77, 0x3E},
        {0x00, 0x22, 0x77, 0x7F, 0x7F, 0x3E, 0x1C, 0x08},
        {0x00, 0x08, 0x1C, 0x3E, 0x7F, 0x3E, 0x1C, 0x08},
        {0x00, 0x08, 0x1C, 0x2A, 0x7F, 0x2A, 0x08, 0x1C},
        {0x00, 0x08, 0x1C, 0x3E, 0x7F, 0x3E, 0x08, 0x1C},
        {0x00, 0x00, 0x1C, 0x3E, 0x3E, 0x3E, 0x1C, 0x00},
        {0xFF, 0xFF, 0xE3, 0xC1, 0xC1, 0xC1, 0xE3, 0xFF},
        {0x00, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x1C, 0x00},
        {0xFF, 0xFF, 0xE3, 0xDD, 0xDD, 0xDD, 0xE3, 0xFF},
        {0x00, 0x0F, 0x03, 0x05, 0x39, 0x48, 0x48, 0x30},
        {0x00, 0x08, 0x3E, 0x08, 0x1C, 0x22, 0x22, 0x1C},
        {0x00, 0x18, 0x14, 0x10, 0x10, 0x30, 0x70, 0x60},
        {0x00, 0x0F, 0x19, 0x11, 0x13, 0x37, 0x76, 0x60},
        {0x00, 0x08, 0x2A, 0x1C, 0x77, 0x1C, 0x2A, 0x08},
        {0x00, 0x60, 0x78, 0x7E, 0x7F, 0x7E, 0x78, 0x60},
        {0x00, 0x03, 0x0F, 0x3F, 0x7F, 0x3F, 0x0F, 0x03},
        {0x00, 0x08, 0x1C, 0x2A, 0x08, 0x2A, 0x1C, 0x08},
        {0x00, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x66},
        {0x00, 0x3F, 0x65, 0x65, 0x3D, 0x05, 0x05, 0x05},
        {0x00, 0x0C, 0x32, 0x48, 0x24, 0x12, 0x4C, 0x30},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x7F, 0x7F},
        {0x00, 0x08, 0x1C, 0x2A, 0x08, 0x2A, 0x1C, 0x3E},
        {0x00, 0x08, 0x1C, 0x3E, 0x7F, 0x1C, 0x1C, 0x1C},
        {0x00, 0x1C, 0x1C, 0x1C, 0x7F, 0x3E, 0x1C, 0x08},
        {0x00, 0x08, 0x0C, 0x7E, 0x7F, 0x7E, 0x0C, 0x08},
        {0x00, 0x08, 0x18, 0x3F, 0x7F, 0x3F, 0x18, 0x08},
        {0x00, 0x00, 0x00, 0x70, 0x70, 0x70, 0x7F, 0x7F},
        {0x00, 0x00, 0x14, 0x22, 0x7F, 0x22, 0x14, 0x00},
        {0x00, 0x08, 0x1C, 0x1C, 0x3E, 0x3E, 0x7F, 0x7F},
        {0x00, 0x7F, 0x7F, 0x3E, 0x3E, 0x1C, 0x1C, 0x08},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18},
        {0x00, 0x36, 0x36, 0x14, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36},
        {0x00, 0x08, 0x1E, 0x20, 0x1C, 0x02, 0x3C, 0x08},
        {0x00, 0x60, 0x66, 0x0C, 0x18, 0x30, 0x66, 0x06},
        {0x00, 0x3C, 0x66, 0x3C, 0x28, 0x65, 0x66, 0x3F},
        {0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00},
        {0x00, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06},
        {0x00, 0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60},
        {0x00, 0x00, 0x36, 0x1C, 0x7F, 0x1C, 0x36, 0x00},
        {0x00, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x60},
        {0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60},
        {0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00},
        {0x00, 0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C},
        {0x00, 0x18, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7E},
        {0x00, 0x3C, 0x66, 0x06, 0x0C, 0x30, 0x60, 0x7E},
        {0x00, 0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C},
        {0x00, 0x0C, 0x1C, 0x2C, 0x4C, 0x7E, 0x0C, 0x0C},
        {0x00, 0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C},
        {0x00, 0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C},
        {0x00, 0x7E, 0x66, 0x0C, 0x0C, 0x18, 0x18, 0x18},
        {0x00, 0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C},
        {0x00, 0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C},
        {0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00},
        {0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30},
        {0x00, 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06},
        {0x00, 0x00, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x00},
        {0x00, 0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60},
        {0x00, 0x3C, 0x66, 0x06, 0x1C, 0x18, 0x00, 0x18},
        {0x00, 0x38, 0x44, 0x5C, 0x58, 0x42, 0x3C, 0x00},
        {0x00, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66},
        {0x00, 0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C},
        {0x00, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C},
        {0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C},
        {0x00, 0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E},
        {0x00, 0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60},
        {0x00, 0x3C, 0x66, 0x60, 0x60, 0x6E, 0x66, 0x3C},
        {0x00, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66},
        {0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C},
        {0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x6C, 0x6C, 0x38},
        {0x00, 0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66},
        {0x00, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E},
        {0x00, 0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63},
        {0x00, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x63, 0x63},
        {0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C},
        {0x00, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60},
        {0x00, 0x3C, 0x66, 0x66, 0x66, 0x6E, 0x3C, 0x06},
        {0x00, 0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66},
        {0x00, 0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C},
        {0x00, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18},
        {0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E},
        {0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18},
        {0x00, 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63},
        {0x00, 0x63, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x63},
        {0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18},
        {0x00, 0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E},
        {0x00, 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E},
        {0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00},
        {0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78},
        {0x00, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F},
        {0x00, 0x0C, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E},
        {0x00, 0x60, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x7C},
        {0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C},
        {0x00, 0x06, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3E},
        {0x00, 0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C},
        {0x00, 0x1C, 0x36, 0x30, 0x30, 0x7C, 0x30, 0x30},
        {0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x3C},
        {0x00, 0x60, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66},
        {0x00, 0x00, 0x18, 0x00, 0x18, 0x18, 0x18, 0x3C},
        {0x00, 0x0C, 0x00, 0x0C, 0x0C, 0x6C, 0x6C, 0x38},
        {0x00, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66},
        {0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
        {0x00, 0x00, 0x00, 0x63, 0x77, 0x7F, 0x6B, 0x6B},
        {0x00, 0x00, 0x00, 0x7C, 0x7E, 0x66, 0x66, 0x66},
        {0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C},
        {0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60},
        {0x00, 0x00, 0x3C, 0x6C, 0x6C, 0x3C, 0x0D, 0x0F},
        {0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x60, 0x60},
        {0x00, 0x00, 0x00, 0x3E, 0x40, 0x3C, 0x02, 0x7C},
        {0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x18},
        {0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E},
        {0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x3C, 0x18},
        {0x00, 0x00, 0x00, 0x63, 0x6B, 0x6B, 0x6B, 0x3E},
        {0x00, 0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66},
        {0x00, 0x00, 0x00, 0x66, 0x66, 0x3E, 0x06, 0x3C},
        {0x00, 0x00, 0x00, 0x3C, 0x0C, 0x18, 0x30, 0x3C},
        {0x00, 0x0E, 0x18, 0x18, 0x30, 0x18, 0x18, 0x0E},
        {0x00, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18},
        {0x00, 0x70, 0x18, 0x18, 0x0C, 0x18, 0x18, 0x70},
        {0x00, 0x00, 0x00, 0x3A, 0x6C, 0x00, 0x00, 0x00},
        {0x00, 0x08, 0x1C, 0x36, 0x63, 0x41, 0x41, 0x7F}
};

static u8* fb = NULL;
static u16 fbWidth = 0;
static u16 fbHeight = 0;

bool screenBeginDraw(Screen screen) {
    if(fb != NULL || !serviceRequire("gfx")) {
        return false;
    }

    gfxScreen_t gfxScreen = screen == TOP_SCREEN ? GFX_TOP : GFX_BOTTOM;
    if(gfxGetScreenFormat(gfxScreen) != GSP_BGR8_OES) {
        return false;
    }

    fb = gfxGetFramebuffer(gfxScreen, GFX_LEFT, &fbWidth, &fbHeight);
    return true;
}

bool screenEndDraw() {
    if(fb == NULL) {
        return false;
    }

    fb = NULL;
    fbWidth = 0;
    fbHeight = 0;
    return true;
}

void screenSwapBuffers(bool vblank) {
    if(!serviceRequire("gfx")) {
        return;
    }

    gfxFlushBuffers();
    if(vblank) {
        gspWaitForVBlank();
    }

    gfxSwapBuffers();
}

u16 screenGetWidth() {
    // Use fbHeight since the framebuffer is rotated 90 degrees to the left.
    return fbHeight;
}

u16 screenGetHeight() {
    // Use fbWidth since the framebuffer is rotated 90 degrees to the left.
    return fbWidth;
}

u32 screenGetIndex(int x, int y) {
    u16 height = screenGetHeight();
    // Reverse the y coordinate when finding the index.
    // This is done as the framebuffer is rotated 90 degrees to the left.
    return (u32) (((height - y - 1) + x * height) * 3);
}

bool screenReadPixels(u8* dest, int srcX, int srcY, u16 srcWidth, u16 srcHeight, int dstX, int dstY, u16 dstWidth, u16 dstHeight) {
    if(fb == NULL || srcX + srcWidth < 0 || srcY + srcHeight < 0 || srcX >= screenGetWidth() || srcY >= screenGetHeight()) {
        return false;
    }

    u16 copyWidth = srcWidth;
    u16 copyHeight = srcHeight;
    if(srcX < 0) {
        dstX -= srcX;
        copyWidth += srcX;
        srcX = 0;
    }

    if(srcY < 0) {
        dstY -= srcY;
        copyHeight += srcY;
        srcY = 0;
    }

    if(srcX + copyWidth > screenGetWidth()) {
        copyWidth = (u16) (screenGetWidth() - srcX);
    }

    if(srcY + copyHeight > screenGetHeight()) {
        copyHeight = (u16) (screenGetHeight() - srcY);
    }

    for(int cx = 0; cx < copyWidth; cx++) {
        for(int cy = 0; cy < copyHeight; cy++) {
            u8* src = fb + screenGetIndex(srcX + cx, srcY + cy);
            u8* dst = dest + (((dstHeight - (dstY + cy) - 1) * dstWidth + (dstX + cx)) * 3);
            dst[0] = src[0];
            dst[1] = src[1];
            dst[2] = src[2];
        }
    }

    return true;
}

bool screenTakeScreenshot() {
    u16 imgWidth = 400;
    u16 imgHeight = 480;
    u16 imgBytesPerPixel = 3;
    u16 imgHeaderSize = 0x36;
    u32 imgDataSize = imgWidth * imgHeight * imgBytesPerPixel;

    u8* temp = (u8*) malloc(imgHeaderSize + imgDataSize);
    memset(temp, 0, imgHeaderSize + imgDataSize);

    *(u16*) &temp[0x0] = 0x4D42;
    *(u32*) &temp[0x2] = imgHeaderSize + imgDataSize;
    *(u32*) &temp[0xA] = imgHeaderSize;
    *(u32*) &temp[0xE] = 0x28;
    *(u32*) &temp[0x12] = imgWidth;
    *(u32*) &temp[0x16] = imgHeight;
    *(u32*) &temp[0x1A] = 0x00180001;
    *(u32*) &temp[0x22] = imgDataSize;

    screenBeginDraw(TOP_SCREEN);
    u16 topWidth = screenGetWidth();
    u16 topHeight = screenGetHeight();
    screenReadPixels(temp + imgHeaderSize, 0, 0, topWidth, topHeight, 0, 0, imgWidth, imgHeight);
    screenEndDraw();

    screenBeginDraw(BOTTOM_SCREEN);
    screenReadPixels(temp + imgHeaderSize, 0, 0, screenGetWidth(), screenGetHeight(), (imgWidth - screenGetWidth()) / 2, topHeight, imgWidth, imgHeight);
    screenEndDraw();

    char file[256];
    snprintf(file, 256, "sdmc:/screenshot_%llu.bmp", osGetTime());
    FILE* fd = fopen(file, "wb");
    if(!fd) {
        free(temp);
        return false;
    }

    fwrite(temp, 1, imgHeaderSize + imgDataSize, fd);
    fclose(fd);
    free(temp);
    return true;
}

bool screenDraw(int x, int y, u8 r, u8 g, u8 b) {
    if(fb == NULL || x < 0 || y < 0 || x >= screenGetWidth() || y >= screenGetHeight()) {
        return false;
    }

    u32 idx = screenGetIndex(x, y);
    fb[idx + 0] = b;
    fb[idx + 1] = g;
    fb[idx + 2] = r;
    return true;
}

bool screenFill(int x, int y, u16 width, u16 height, u8 r, u8 g, u8 b) {
    if(fb == NULL) {
        return false;
    }

    u16 swidth = screenGetWidth();
    u16 sheight = screenGetHeight();
    if(x + width < 0 || y + height < 0 || x >= swidth || y >= sheight) {
        return false;
    }

    if(x < 0) {
        width += x;
        x = 0;
    }

    if(y < 0) {
        height += y;
        y = 0;
    }

    if(x + width >= swidth) {
        width = (u16) (swidth - x);
    }

    if(y + height >= sheight) {
        height = (u16) (sheight - y);
    }

    u8 colorLine[height * 3];
    for(int ly = 0; ly < height; ly++) {
        colorLine[ly * 3 + 0] = b;
        colorLine[ly * 3 + 1] = g;
        colorLine[ly * 3 + 2] = r;
    }

    u8* fbAddr = fb + screenGetIndex(x, y) - ((height - 1) * 3);
    for(int dx = 0; dx < width; dx++) {
        memcpy(fbAddr, colorLine, (size_t) (height * 3));
        fbAddr += sheight * 3;
    }

    return true;
}

bool screenCopy(int x, int y, u16 width, u16 height, u8* pixels) {
    if(fb == NULL) {
        return false;
    }

    u16 swidth = screenGetWidth();
    u16 sheight = screenGetHeight();
    if(x + width < 0 || y + height < 0 || x >= swidth || y >= sheight) {
        return false;
    }

    if(x < 0) {
        width += x;
        x = 0;
    }

    if(y < 0) {
        height += y;
        y = 0;
    }

    if(x + width >= swidth) {
        width = (u16) (swidth - x);
    }

    if(y + height >= sheight) {
        height = (u16) (sheight - y);
    }

    u8* colorLine = pixels;
    u8* fbAddr = fb + screenGetIndex(x, y) - ((height - 1) * 3);
    for(int dx = 0; dx < width; dx++) {
        memcpy(fbAddr, colorLine, (size_t) (height * 3));
        colorLine += height * 3;
        fbAddr += sheight * 3;
    }

    return true;
}

bool screenClear(u8 r, u8 g, u8 b) {
    if(fb == NULL) {
        return false;
    }

    if(r == g && r == b) {
        memset(fb, r, (size_t) (fbWidth * fbHeight * 3));
        return true;
    } else {
        return screenFill(0, 0, screenGetWidth(), screenGetHeight(), r, g, b);
    }
}

void screenClearBuffers(Screen screen, u8 r, u8 g, u8 b) {
    for(int buffer = 0; buffer < 2; buffer++) {
        screenBeginDraw(screen);
        screenClear(r, g, b);
        screenEndDraw();

        screenSwapBuffers();
    }
}

void screenClearAll(u8 r, u8 g, u8 b) {
    for(int buffer = 0; buffer < 2; buffer++) {
        screenBeginDraw(TOP_SCREEN);
        screenClear(r, g, b);
        screenEndDraw();

        screenBeginDraw(BOTTOM_SCREEN);
        screenClear(r, g, b);
        screenEndDraw();

        screenSwapBuffers();
    }
}

u16 screenGetStrWidth(const std::string str) {
    u32 len = str.length();
    if(len == 0) {
        return 0;
    }

    u32 longestLine = 0;
    u32 currLength = 0;
    for(u32 i = 0; i < len; i++) {
        if(str[i] == '\n') {
            if(currLength > longestLine) {
                longestLine = currLength;
            }

            currLength = 0;
            continue;
        }

        currLength++;
    }

    if(currLength > longestLine) {
        longestLine = currLength;
    }

    return (u16) (longestLine * 8);
}

u16 screenGetStrHeight(const std::string str) {
    u32 len = str.length();
    if(len == 0) {
        return 0;
    }

    u32 lines = 1;
    for(u32 i = 0; i < len; i++) {
        if(str[i] == '\n') {
            lines++;
        }
    }

    return (u16) (lines * 8);
}

bool screenDrawChar(char c, int x, int y, u8 r, u8 g, u8 b) {
    if(fb == NULL) {
        return false;
    }

    bool drawn = false;
    unsigned char* data = asciiData[(int) c];
    for(int cy = 0; cy < 8; cy++) {
        unsigned char l = data[cy];
        for(int cx = 0; cx < 8; cx++) {
            if((0b10000000 >> cx) & l) {
                drawn = true;
                screenDraw(x + cx, y + cy, r, g, b);
            }
        }
    }

    return drawn;
}

bool screenDrawString(const std::string str, int x, int y, u8 r, u8 g, u8 b) {
    if(fb == NULL) {
        return false;
    }

    int len = str.length();
    int cx = x;
    int cy = y;
    for(int i = 0; i < len; i++) {
        char c = str[i];
        if(c == '\n') {
            cx = x;
            cy += 8;
            continue;
        }

        screenDrawChar(c, cx, cy, r, g, b);
        cx += 8;
    }

    return true;
}